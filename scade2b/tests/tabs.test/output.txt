

 Node Parsed :
NODE vect_real_op_slice (x : real ^ 4) RETURNS (y : real ^ 2) 
VAR ; 
LET 
    
     
   y = x[1 .. 2];  
TEL 

Node normalized : 
NODE vect_real_op_slice (x : real ^ 4) RETURNS (y : real ^ 2) 
VAR ; 
PRE : x : real ^ 4 
LET 
   y = x[[1 .. 2]]; 
TEL 
POST : y : real ^ 2  
LAMBDAS :  

Node normalized : 
NODE vect_real_op_slice (x : real ^ 4) RETURNS (y : real ^ 2) 
VAR ; 
PRE : x : real ^ 4 
LET 
   y = x[[1 .. 2]]; 
TEL 
POST : y : real ^ 2  
LAMBDAS :  



 Node Parsed :
NODE vect_real_op_caret (x : real) RETURNS (y : real ^ 2) 
VAR ; 
LET 
    
     
   y = 3.200000 ^ 2;  
TEL 

Node normalized : 
NODE vect_real_op_caret (x : real) RETURNS (y : real ^ 2) 
VAR ; 
PRE : x : real 
LET 
   y = (3.200000 ^ 2); 
TEL 
POST : y : real ^ 2  
LAMBDAS :  

Node normalized : 
NODE vect_real_op_caret (x : real) RETURNS (y : real ^ 2) 
VAR ; 
PRE : x : real 
LET 
   y = (3.200000 ^ 2); 
TEL 
POST : y : real ^ 2  
LAMBDAS :  



 Node Parsed :
NODE vect_real_op_index (x : real ^ 2) RETURNS (y : real) 
VAR ; 
LET 
    
     
   y = x[0];  
TEL 

Node normalized : 
NODE vect_real_op_index (x : real ^ 2) RETURNS (y : real) 
VAR ; 
PRE : x : real ^ 2 
LET 
   y = x[[0]]; 
TEL 
POST : y : real  
LAMBDAS :  

Node normalized : 
NODE vect_real_op_index (x : real ^ 2) RETURNS (y : real) 
VAR ; 
PRE : x : real ^ 2 
LET 
   y = x[[0]]; 
TEL 
POST : y : real  
LAMBDAS :  



 Node Parsed :
NODE mat_real_op_def (x : real ^ 2; z : real ^ 2) RETURNS (y : real ^ 2 ^ 2) 
VAR ASSUME and(gt(x, 0.000000), lt(x, 1000.000000)); 
LET 
  GUARANTEE and(gt(y, 0.000000), lt(y, 1000.000000))  
     
   y = [x, z];  
TEL 

Node normalized : 
NODE mat_real_op_def (x : real ^ 2; z : real ^ 2) RETURNS (y : real ^ 2 ^ 2) 
VAR ; 
PRE : z : real ^ 2 ;
      x : real ^ 2 & and(gt(x, 0.000000), lt(x, 1000.000000))
LET 
   y = def[ x, z ]; 
TEL 
POST : y : real ^ 2 ^ 2 & and(gt(y, 0.000000), lt(y, 1000.000000)) 
LAMBDAS :  

Node normalized : 
NODE mat_real_op_def (x : real ^ 2; z : real ^ 2) RETURNS (y : real ^ 2 ^ 2) 
VAR ; 
PRE : z : real ^ 2 ;
      x : real ^ 2 & and(gt(x, 0.000000), lt(x, 1000.000000))
LET 
   y = def[ x, z ]; 
TEL 
POST : y : real ^ 2 ^ 2 & and(gt(y, 0.000000), lt(y, 1000.000000)) 
LAMBDAS :  



 Node Parsed :
NODE vect_real_op_def (x : real; z : real) RETURNS (y : real ^ 2) 
VAR ; 
LET 
    
     
   y = [x, z];  
TEL 

Node normalized : 
NODE vect_real_op_def (x : real; z : real) RETURNS (y : real ^ 2) 
VAR ; 
PRE : z : real ;
      x : real 
LET 
   y = def[ x, z ]; 
TEL 
POST : y : real ^ 2  
LAMBDAS :  

Node normalized : 
NODE vect_real_op_def (x : real; z : real) RETURNS (y : real ^ 2) 
VAR ; 
PRE : z : real ;
      x : real 
LET 
   y = def[ x, z ]; 
TEL 
POST : y : real ^ 2  
LAMBDAS :  



 Node Parsed :
NODE vect_real_op_concat (x : real ^ 2; z : real ^ 2) RETURNS (y : real ^ 4) 
VAR ; 
LET 
    
     
   y = x | z;  
TEL 

Node normalized : 
NODE vect_real_op_concat (x : real ^ 2; z : real ^ 2) RETURNS (y : real ^ 4) 
VAR ; 
PRE : z : real ^ 2 ;
      x : real ^ 2 
LET 
   y = x | z; 
TEL 
POST : y : real ^ 4  
LAMBDAS :  

Node normalized : 
NODE vect_real_op_concat (x : real ^ 2; z : real ^ 2) RETURNS (y : real ^ 4) 
VAR ; 
PRE : z : real ^ 2 ;
      x : real ^ 2 
LET 
   y = x | z; 
TEL 
POST : y : real ^ 4  
LAMBDAS :  



 Node Parsed :
NODE vect_real_op_rev (x : real ^ 2) RETURNS (y : real ^ 2) 
VAR ; 
LET 
    
     
   y = rev(x);  
TEL 

Node normalized : 
NODE vect_real_op_rev (x : real ^ 2) RETURNS (y : real ^ 2) 
VAR ; 
PRE : x : real ^ 2 
LET 
   y = rev(x); 
TEL 
POST : y : real ^ 2  
LAMBDAS :  

Node normalized : 
NODE vect_real_op_rev (x : real ^ 2) RETURNS (y : real ^ 2) 
VAR ; 
PRE : x : real ^ 2 
LET 
   y = rev(x); 
TEL 
POST : y : real ^ 2  
LAMBDAS :  



 Node Parsed :
NODE vect_real_op_aff (x : real ^ 2) RETURNS (y : real ^ 2) 
VAR ; 
LET 
    
     
   y = x;  
TEL 

Node normalized : 
NODE vect_real_op_aff (x : real ^ 2) RETURNS (y : real ^ 2) 
VAR ; 
PRE : x : real ^ 2 
LET 
   y = x; 
TEL 
POST : y : real ^ 2  
LAMBDAS :  

Node normalized : 
NODE vect_real_op_aff (x : real ^ 2) RETURNS (y : real ^ 2) 
VAR ; 
PRE : x : real ^ 2 
LET 
   y = x; 
TEL 
POST : y : real ^ 2  
LAMBDAS :  



 Node Parsed :
NODE vect_bool_op_slice (x : bool ^ 4) RETURNS (y : bool ^ 2) 
VAR ; 
LET 
    
     
   y = x[1 .. 2];  
TEL 

Node normalized : 
NODE vect_bool_op_slice (x : bool ^ 4) RETURNS (y : bool ^ 2) 
VAR ; 
PRE : x : bool ^ 4 
LET 
   y = x[[1 .. 2]]; 
TEL 
POST : y : bool ^ 2  
LAMBDAS :  

Node normalized : 
NODE vect_bool_op_slice (x : bool ^ 4) RETURNS (y : bool ^ 2) 
VAR ; 
PRE : x : bool ^ 4 
LET 
   y = x[[1 .. 2]]; 
TEL 
POST : y : bool ^ 2  
LAMBDAS :  



 Node Parsed :
NODE vect_bool_op_caret (x : bool) RETURNS (y : bool ^ 2) 
VAR ; 
LET 
    
     
   y = true ^ 2;  
TEL 

Node normalized : 
NODE vect_bool_op_caret (x : bool) RETURNS (y : bool ^ 2) 
VAR ; 
PRE : x : bool 
LET 
   y = (true ^ 2); 
TEL 
POST : y : bool ^ 2  
LAMBDAS :  

Node normalized : 
NODE vect_bool_op_caret (x : bool) RETURNS (y : bool ^ 2) 
VAR ; 
PRE : x : bool 
LET 
   y = (true ^ 2); 
TEL 
POST : y : bool ^ 2  
LAMBDAS :  



 Node Parsed :
NODE vect_bool_op_index (x : bool ^ 2) RETURNS (y : bool) 
VAR ; 
LET 
    
     
   y = x[0];  
TEL 

Node normalized : 
NODE vect_bool_op_index (x : bool ^ 2) RETURNS (y : bool) 
VAR ; 
PRE : x : bool ^ 2 
LET 
   y = x[[0]]; 
TEL 
POST : y : bool  
LAMBDAS :  

Node normalized : 
NODE vect_bool_op_index (x : bool ^ 2) RETURNS (y : bool) 
VAR ; 
PRE : x : bool ^ 2 
LET 
   y = x[[0]]; 
TEL 
POST : y : bool  
LAMBDAS :  



 Node Parsed :
NODE vect_bool_op_def (x : bool; z : bool) RETURNS (y : bool ^ 2) 
VAR ; 
LET 
    
     
   y = [x, z];  
TEL 

Node normalized : 
NODE vect_bool_op_def (x : bool; z : bool) RETURNS (y : bool ^ 2) 
VAR ; 
PRE : z : bool ;
      x : bool 
LET 
   y = def[ x, z ]; 
TEL 
POST : y : bool ^ 2  
LAMBDAS :  

Node normalized : 
NODE vect_bool_op_def (x : bool; z : bool) RETURNS (y : bool ^ 2) 
VAR ; 
PRE : z : bool ;
      x : bool 
LET 
   y = def[ x, z ]; 
TEL 
POST : y : bool ^ 2  
LAMBDAS :  



 Node Parsed :
NODE vect_bool_op_concat (x : bool ^ 2; z : bool ^ 2) RETURNS (y : bool ^ 4) 
VAR ; 
LET 
    
     
   y = x | z;  
TEL 

Node normalized : 
NODE vect_bool_op_concat (x : bool ^ 2; z : bool ^ 2) RETURNS (y : bool ^ 4) 
VAR ; 
PRE : z : bool ^ 2 ;
      x : bool ^ 2 
LET 
   y = x | z; 
TEL 
POST : y : bool ^ 4  
LAMBDAS :  

Node normalized : 
NODE vect_bool_op_concat (x : bool ^ 2; z : bool ^ 2) RETURNS (y : bool ^ 4) 
VAR ; 
PRE : z : bool ^ 2 ;
      x : bool ^ 2 
LET 
   y = x | z; 
TEL 
POST : y : bool ^ 4  
LAMBDAS :  



 Node Parsed :
NODE vect_bool_op_rev (x : bool ^ 2) RETURNS (y : bool ^ 2) 
VAR ; 
LET 
    
     
   y = rev(x);  
TEL 

Node normalized : 
NODE vect_bool_op_rev (x : bool ^ 2) RETURNS (y : bool ^ 2) 
VAR ; 
PRE : x : bool ^ 2 
LET 
   y = rev(x); 
TEL 
POST : y : bool ^ 2  
LAMBDAS :  

Node normalized : 
NODE vect_bool_op_rev (x : bool ^ 2) RETURNS (y : bool ^ 2) 
VAR ; 
PRE : x : bool ^ 2 
LET 
   y = rev(x); 
TEL 
POST : y : bool ^ 2  
LAMBDAS :  



 Node Parsed :
NODE vect_bool_op_aff (x : bool ^ 2) RETURNS (y : bool ^ 2) 
VAR ; 
LET 
    
     
   y = x;  
TEL 

Node normalized : 
NODE vect_bool_op_aff (x : bool ^ 2) RETURNS (y : bool ^ 2) 
VAR ; 
PRE : x : bool ^ 2 
LET 
   y = x; 
TEL 
POST : y : bool ^ 2  
LAMBDAS :  

Node normalized : 
NODE vect_bool_op_aff (x : bool ^ 2) RETURNS (y : bool ^ 2) 
VAR ; 
PRE : x : bool ^ 2 
LET 
   y = x; 
TEL 
POST : y : bool ^ 2  
LAMBDAS :  



 Node Parsed :
NODE vect_int_op_slice (x : int ^ 4) RETURNS (y : int ^ 2) 
VAR ; 
LET 
    
     
   y = x[1 .. 2];  
TEL 

Node normalized : 
NODE vect_int_op_slice (x : int ^ 4) RETURNS (y : int ^ 2) 
VAR ; 
PRE : x : int ^ 4 
LET 
   y = x[[1 .. 2]]; 
TEL 
POST : y : int ^ 2  
LAMBDAS :  

Node normalized : 
NODE vect_int_op_slice (x : int ^ 4) RETURNS (y : int ^ 2) 
VAR ; 
PRE : x : int ^ 4 
LET 
   y = x[[1 .. 2]]; 
TEL 
POST : y : int ^ 2  
LAMBDAS :  



 Node Parsed :
NODE vect_int_op_caret (x : int) RETURNS (y : int ^ 2) 
VAR ; 
LET 
    
     
   y = 3 ^ 2;  
TEL 

Node normalized : 
NODE vect_int_op_caret (x : int) RETURNS (y : int ^ 2) 
VAR ; 
PRE : x : int 
LET 
   y = (3 ^ 2); 
TEL 
POST : y : int ^ 2  
LAMBDAS :  

Node normalized : 
NODE vect_int_op_caret (x : int) RETURNS (y : int ^ 2) 
VAR ; 
PRE : x : int 
LET 
   y = (3 ^ 2); 
TEL 
POST : y : int ^ 2  
LAMBDAS :  



 Node Parsed :
NODE vect_int_op_index (x : int ^ 2) RETURNS (y : int) 
VAR ; 
LET 
    
     
   y = x[0];  
TEL 

Node normalized : 
NODE vect_int_op_index (x : int ^ 2) RETURNS (y : int) 
VAR ; 
PRE : x : int ^ 2 
LET 
   y = x[[0]]; 
TEL 
POST : y : int  
LAMBDAS :  

Node normalized : 
NODE vect_int_op_index (x : int ^ 2) RETURNS (y : int) 
VAR ; 
PRE : x : int ^ 2 
LET 
   y = x[[0]]; 
TEL 
POST : y : int  
LAMBDAS :  



 Node Parsed :
NODE vect_int_op_def (x : int; z : int) RETURNS (y : int ^ 2) 
VAR ; 
LET 
    
     
   y = [x, z];  
TEL 

Node normalized : 
NODE vect_int_op_def (x : int; z : int) RETURNS (y : int ^ 2) 
VAR ; 
PRE : z : int ;
      x : int 
LET 
   y = def[ x, z ]; 
TEL 
POST : y : int ^ 2  
LAMBDAS :  

Node normalized : 
NODE vect_int_op_def (x : int; z : int) RETURNS (y : int ^ 2) 
VAR ; 
PRE : z : int ;
      x : int 
LET 
   y = def[ x, z ]; 
TEL 
POST : y : int ^ 2  
LAMBDAS :  



 Node Parsed :
NODE vect_int_op_concat (x : int ^ 2; z : int ^ 2) RETURNS (y : int ^ 4) 
VAR ; 
LET 
    
     
   y = x | z;  
TEL 

Node normalized : 
NODE vect_int_op_concat (x : int ^ 2; z : int ^ 2) RETURNS (y : int ^ 4) 
VAR ; 
PRE : z : int ^ 2 ;
      x : int ^ 2 
LET 
   y = x | z; 
TEL 
POST : y : int ^ 4  
LAMBDAS :  

Node normalized : 
NODE vect_int_op_concat (x : int ^ 2; z : int ^ 2) RETURNS (y : int ^ 4) 
VAR ; 
PRE : z : int ^ 2 ;
      x : int ^ 2 
LET 
   y = x | z; 
TEL 
POST : y : int ^ 4  
LAMBDAS :  



 Node Parsed :
NODE vect_int_op_rev (x : int ^ 2) RETURNS (y : int ^ 2) 
VAR ; 
LET 
    
     
   y = rev(x);  
TEL 

Node normalized : 
NODE vect_int_op_rev (x : int ^ 2) RETURNS (y : int ^ 2) 
VAR ; 
PRE : x : int ^ 2 
LET 
   y = rev(x); 
TEL 
POST : y : int ^ 2  
LAMBDAS :  

Node normalized : 
NODE vect_int_op_rev (x : int ^ 2) RETURNS (y : int ^ 2) 
VAR ; 
PRE : x : int ^ 2 
LET 
   y = rev(x); 
TEL 
POST : y : int ^ 2  
LAMBDAS :  



 Node Parsed :
NODE vect_int_op_aff (x : int ^ 2) RETURNS (y : int ^ 2) 
VAR ; 
LET 
    
     
   y = x;  
TEL 

Node normalized : 
NODE vect_int_op_aff (x : int ^ 2) RETURNS (y : int ^ 2) 
VAR ; 
PRE : x : int ^ 2 
LET 
   y = x; 
TEL 
POST : y : int ^ 2  
LAMBDAS :  

Node normalized : 
NODE vect_int_op_aff (x : int ^ 2) RETURNS (y : int ^ 2) 
VAR ; 
PRE : x : int ^ 2 
LET 
   y = x; 
TEL 
POST : y : int ^ 2  
LAMBDAS :  

