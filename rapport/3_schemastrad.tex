% -*- coding: utf-8; ispell-dictionary: "french"; -*-

%------------------------------------
% Chapter 3 - Schémas de traduction
%------------------------------------


Dans les deux parties précédentes, nous avons posé les différents
éléments de Scade et de la méthode B dont nous avions besoin pour
établir la traduction. Cette partie définit les schémas de traduction
utilisés pour réaliser le traducteur. \\

\section{Spécification}

La machine abstraite est engendrée à partir du contrat du composant. Ce sont
donc les conditions posées par les instructions \texttt{assume} et
\texttt{guarantee} qui nous intéressent. Le nom de l'opération sera le même que le
nom de la définition Scade. 

\subsection{Traduction de la déclaration du noeud}
La déclaration d'un noeud Scade comporte le nom du composant, ses
entrées/sorties, et le type de ses entrées/sorties. En B, on reprend ces
informations sur le nom du noeud et le nom des entrées sorties pour déclarer une
opération. Ainsi la déclaration Scade: 
\begin{alltt}
node mon\_noeud (in_1: type\_in_1, ..., in_n: type\_in_n) 
                returns (out_1: type\_out_1, ..., out_m: type\_out_m);
\end{alltt}
devient l'operation B:
\begin{alltt}
in_1, ..., in_n \(\leftarrow\) mon\_noeud(out_1, ..., out_m) =
\end{alltt}

\noindent
En reprenant le noeud \texttt{bound}, la traduction donne:\\
\texttt{vv $\leftarrow$ bound(zz, b\_inf, b\_sup) =}\\
On peut noter que le nom de la variable de sortie a été
modifié par rapport à la version de Scade. Dans B, les noms de variables n'ayant qu'une lettre sont
réservés, donc on effectue un rennomage sur l'ensemble des variables
du programmes: les lettres simples sont doublées, et si le nouveau nom
est déjà utilisé par une autre variable, on redouble le nom jusqu'à ce
qu'il n'y ai aucun conflit dans les noms de variables.

\paragraph{Traduction des types de base}
Les informations de types sur les entrées et sorties sont reprises pour les
préconditions et postconditions.
La traduction des types de base est directe:
\begin{itemize}
\item int est traduit par INT
\item real est traduit par REAL
\item bool est traduit par BOOL
\end{itemize}


\subsection{Traduction des conditions}

La machine abstraite de B forme une spécification de la machine implanté,
l'opération est ainsi ordinairement consitué d'une substitution précondition
PRE P THEN S END. P étant le prédicat correspondant aux conditions des
\texttt{assumes} et aux informations de typage sur les entrées, tandis que S est
la substitution qui reprend les conditions sur les \texttt{guarantees} et les informations de typage
sur les sorties. 

\paragraph{Traduction des préconditions}
Les instructions \texttt{assumes} sont des formules logiques, généralement des
restrictions sur des intervalles. Les opérateurs logiques utilisés sont les
mêmes pour Scade que pour le langage B, la traduction est donc directe. Les
conditions sur les différentes entrées sont combinées par un opérateur ET
logique (\&). La condition est précédée par le type de la variable, reprit
depuis la déclaration Scade. 
Dans le cas où une variable d'entrée ou de sortie n'est pas conditionnée, comme
c'est souvent le cas pour les variables booléennes, alors on indique seulement
le type de la variable.

\noindent
En reprenant l'exemple bound, les prédicats générés pour les
préconditions sont:\\

\noindent
\texttt{zz $\in$ INT \& zz <= 2000 \& zz >= -2000 \& \\
b\_sup $\in$ INT \& b\_sup <= 2000 \& b\_sup >= -2000 \& \\
b\_inf $\in$ INT \& b\_inf <= 2000 \& b\_inf >= -2000 \\
}


\paragraph{Traduction des postconditions}
Les instructions \texttt{guarantee} sont également des formules
logiques. Cependant, on utilise des substitution \emph{Devient Element De} pour
les post-conditions, que l'on combine avec une définition d'ensemble
en compréhension. Les variables en sortie auront une valeur respectant
la postcondition qui va être utilisée pour définir l'ensemble en
compréhension. 
Les substitutions sont regroupée dans une substitution parallèle,
elles sont séparées par un ||. 
Les substitutions seront de la forme:
\begin{alltt}
out \(\in\): \{ iii | iii \(\in\) type_out & C \}
\end{alltt}
avec \texttt{out} la variable de sortie, \texttt{type\_out} son type, et \texttt{C} la
postcondition associée.\\
En reprenant l'exemple de \texttt{bound} on obtient pour v:\\
\texttt{vv $\in$: \{ iii | iii $\in$ INT \& iii <= 200 \& iii >= -2000 \}}



\subsection{Le cas des tableaux}
La traduction des conditions pour les tableaux est moins directe, car il n'y a
pas de type primitif pour les tableaux en B. On utilise des fonctions à la
place. 

\paragraph{Traduction des types}
Les tableaux peuvent être multi-dimensionnels, mais ne peuvent contenir qu'un
seul type de donnée. On peut voir les tableaux comme des fonctions prennant
comme argument l'indice de la donnée stockée, et retournant la valeur de cette
donnée. Les tableaux sont indexés par des entiers, sélectionnés dans les
intervalles allant de 1 à la taille du tableau.
Par exemple, pour une matrice \emph{Mat} de n lignes et m colonnes, les valeurs
des données sont accessibles ainsi: $Mat(p, q)$, avec $1 \leq p \leq n$ et $1 \leq q
\leq m$.
Ainsi, le schéma correspondant à la traduction de la déclaration d'un tableau
est:
\begin{alltt}
nom\_tableau : type\_tableau \^ dim_1 \^ ... \^ dim_n
\end{alltt}
devient la substitution B:
\begin{alltt}
nom\_tableau : (1..dim_1, ..., 1..dim_n) \(\rightarrow\) type\_tableau 
\end{alltt}
Dans la traduction B, la notation \texttt{1..dim$_1$} correspond à un
intervalle allant de \texttt{1} à la valeur de \texttt{dim$_1$}
\paragraph{Traduction des formules logiques}
Les conditions sur les tableaux en B ont été évoquées dans la section sur les
quantificateurs en B. Les conditions portent sur l'ensemble des données
contenues dans le tableau. La condition est alors de la forme: pour toute valeur
iii correspondant à un index du tableau, la donnée référencée par cet index
respecte la condition donnée. Ainsi, une formule logique \texttt{f\_l} portant sur un
tableau \texttt{T} de n dimensions correspond à la formule B: 
\begin{alltt}
\(\forall \)iii. (iii : (1..dim_1, ..., 1..dim_n) \(\rightarrow\) f\_l)
\end{alltt}

Prenons par exemple un tableau T de taille 2 comprenant des entiers. La condition
associée à T est que ses éléments doivent être compris entre 0 et 10 exclus.\\
Le type du tableau sera alors: \\
\texttt{T : (1 .. 2) $\rightarrow$ INT }\\
Et la formule associée au tableau sera: \\
\texttt{$\forall$iii. (iii $\in$ (1 .. 2) => 0 < T(iii) \& T(iii) < 10)}

\subsection{schéma général}

Le schéma de traduction d'un composant Scade foo en une machine abstraite B est
le suivant:

\setlength{\columnseprule}{0.05cm}
\begin{multicols}{2}
\begin{alltt}
\textbf{node} foo 
  (in\(\sb{1}\): in\(\sb{1}\)\_type, ..., in\(\sb{p}\): in\(\sb{p}\)\_type) 
  \textbf{returns}
  (out\(\sb{1}\): out\(\sb{1}\)\_type, ..., out\(\sb{q}\): out\(\sb{q}\)\_type);
\textbf{var}

  ...

\textbf{let}
  assume A\(\sb{1}\) : pred\_in\(\sb{1}\);
  ...
  assume A\(\sb{p}\) : pred\_in\(\sb{p}\);

  \( liste d'equations \)

  guarantee G\(\sb{1}\) : pred\_out\(\sb{1}\);
  ...
  guarantee G\(\sb{q}\) : pred\_out\(\sb{q}\);
\textbf{tel;}
\end{alltt}
\columnbreak

\begin{alltt}
\textbf{MACHINE} Foo

\textbf{OPERATION}

out\(\sb{1}\), ..., out\(\sb{q}\) \(\leftarrow\) foo(in\(\sb{1}\), ..., in\(\sb{p}\)) =
  \textbf{PRE}
    in\(\sb{1}\) \(\in\) in\(\sb{1}\)\_type & pred\_in\(\sb{1}\) &
    ... &
    in\(\sb{p}\) \(\in\) in\(\sb{p}\)\_type & pred\_in\(\sb{p}\) &
  \textbf{THEN}
    out\(\sb{1}\) \(\in\): \{ iii | iii \(\in\) out\(\sb{1}\)\_type & pred\_out\(\sb{1}\)\}
    ...
    out\(\sb{q}\) \(\in\): \{ iii | iii \(\in\) out\(\sb{q}\)\_type & pred\_out\(\sb{q}\)\}
  \textbf{END}
\textbf{END}
\end{alltt}
\end{multicols}

\noindent
Les formules booléennes sont notées \texttt{pred\_nom} où nom
correspond au nom de la variable concernée par cette formule, qui à
la même syntaxe en Scade et en B. De plus, les variables locales ne sont pas
considérées dans la machine abstraite.

\section{Implémentation}


\subsection{Traduction des équations}

Les équations sont traduites différemment selon le "type" d'expression qu'elles
contiennent.  
Concernant la partie droite, il y a 4 types d'expressions de Scade à traduire en B:
\begin{itemize}
\item Les expressions à manipulant les variables, constantes et opérateurs de
  base (arithmétiques, relationnels, booléens,...).
\item Les appels de noeuds, sous réserve que le noeud appelé a déjà été
  traduit. 
\item L'alternative.
\item Le registre.
\end{itemize}

\paragraph{Opérateurs de base}
Les opérateurs de base sont traduits par une substitution \emph{Devient Egal}, on
effectue une simple affectation. Les opérateurs de base de Scade sont identiques
à ceux du langage B. Le membre gauche de l'équation correspond à une unique
variable, les opérations étant atomiques dans Scade. \\

\texttt{$a = op(b_1,...,b_n)$ $\xrightarrow{traduction ~ equations}$ $a:=op(b_1,...,b_n)$. }

\paragraph{Appel de noeud}
Un appel de noeud est traduit par une substitution \emph{Appel d'Opération}. Le
membre gauche de l'équation contient autant de variables qu'il y a de sorties
pour le noeud appelé. Le noeud appelé doit avoir été traduit auparavant, et la
machine B correspondante doit être présente dans la clause \texttt{IMPORT}.\\

\texttt{$(a_1, ... a_n) = n(b_1, ..., b_m)$ $\xrightarrow{traduction ~ equations}$ $(a_1, ... a_n) \leftarrow n(b_1,
..., b_n)$}

\paragraph{Alternative}
On traduit l'alternative par la substitution \emph{Condition}. On utilise
également la substitution \emph{Devient Egal} pour chaque branche de l'alternative.\\

\texttt{$ a = if~ cond~ then~ b1~ else~ b2$ $\xrightarrow{traduction ~ equations}$ $IF ~cond~ THEN ~a:=b1~ ELSE
~a:=b2$}

\paragraph{Registre}
Le registre est également traduit en substitution \emph{Devient Egal}, cependant
les substitutions correspondantes doivent être placées après les autres. Ces
équations correspondent à la mise à jour de l'état d'une variable, la mise à
jour est donc faite à la fin de l'opération. La valeur initiale du registre doit
être indiquée dans la clause \texttt{INITIALISATION} de la machine et la variable d'état
correspondant au registre doit être déclarée dans \texttt{CONCRETE\_VARIABLE}. De
plus il faut indiquer dans la clause \texttt{INVARIANT} les contraintes de typage
de la variable d'état. \\

\texttt{$a = ini \rightarrow (pre ~b)$ $\xrightarrow{traduction ~ equations}$ $a := b$ }

\section*{Séquencement des équations}

Dans Scade, l'ordre des équations n'a pas d'importance, mais en B elles doivent
s'exécuter en séquence. Les équations correspondants aux registres sont
automatiquements placées à la fin, car elles mettent à jour l'état de la machine
après son exécution. Il faut donc effectuer un tri topologique des 3 autres
types d'équations.\\
On utilise alors une fonction de tri prenant en entrées :
\begin{itemize}
\item la liste des équations du programme (sans les équations de registre)
\item la liste des variables d'entrée du programme. 
\item la
\end{itemize}
La fonction retourne une liste d'équations triées selon l'ordre
topologique.

\begin{alltt}
Fonction Tri (eqs: liste d'equations, vars\_in: liste de variables)

eq\_non\_triees : liste d'equations
eq\_admis : liste d'equations
v\_admis : liste de variables 
eq : equation

BEGIN
 eq\_non\_triees <- eqs;
 v\_admis <- vars\_in;
 TANT QUE (eq\_non\_triees \(\neq \emptyset \)) 
    eq <- tete(eq\_non\_triees);
    SI vars\_droite(eq) \(\subset\) v\_admis ALORS
       ajout\_fin(eq\_admis, eq);
       ajout\_fin(v\_admis, vars\_gauche(eq))
    SINON
       ajout\_fin(eq\_non\_triees, eq)
    FIN SI
 FIN TANT QUE
 RETOURNE eq\_admis;
END

\end{alltt}

On utilise 4 procédures externes nécessaires à cet algorithme:
\begin{itemize}
\item \texttt{tete(l)} : retourne le premier élément de la liste \texttt{l} et supprime l'élément
  en question de \texttt{l}
\item \texttt{ajout\_fin(l,e)} : ajoute \texttt{e} à la fin de la liste \texttt{l}
\item \texttt{vars\_droite(e)} : liste des variables contenues dans la partie droite de
  l'équation \texttt{e}
\item \texttt{vars\_gauche(e)} : liste des variables contenues dans la partie gauche de
  l'équation \texttt{e}
\end{itemize}
Pour commencer, les variables d'entrées sont considérées comme admises. Les
premières équations sont celles dont la partie droite ne dépend que des
variables admises. La partie gauche des premières équations est ajoutée à la
liste des variables admises, et on ajoute les équations dont la partie droite
dépend du nouvel ensemble de variables admises. La fonction retourne la liste d'
équations triée.

\subsection{Retour sur la traduction des registres}
Dans Scade, les équations correspondant aux registres sont initialisées à une
certaine valeur, puis ils prennent la valeur d'une autre variable pour les
instants suivants. Avec B, les registres sont des variables
d'état, qui auront lors de l'initialisation du programme la valeur définie pour
le premier instant avec Scade.
Cette initialisation de registre doit se faire dans la clause \texttt{INITIALISATION}, et
le nom du registre doit auparavant être déclaré dans la clause \texttt{CONCRETE\_VARIABLES}. L'information de
type du registre doit alors être déclarée comme prédicat dans la clause
\texttt{INVARIANT}. De plus, si le registre porte sur une variable d'entrée ou de sortie,
on peut alors récupérer la condition (si elle existe) sur l'entrée ou la sortie
en question pour compléter le prédicat de la clause \texttt{INVARIANT}. 

Ainsi, soit un registre reg de type t, ayant l'équation suivante :\\
$reg = ini \rightarrow (pre ~a)$ \\
avec a une variable d'entrée ou de sortie du composant, possédant une
précondition ou postcondition P, et ini une valeur d'initialisation de
reg. Il faudra alors écrire dans l'implantation correspondante: 

RENNOMAGE

\begin{alltt}
\textbf{IMPLEMENTATION} ...
...

\textbf{CONCRETE\_VARIABLES} ..., reg
\textbf{INVARIANT}
  ...& reg : t & P
\textbf{INITIALISATION}
  ... ; rn := ini;

\textbf{OPERATION}
... =
\textbf{VAR} ... \textbf{IN}
  ...;
  reg := a
\textbf{END}
\end{alltt}

\subsection{Gestion des clauses SEES et IMPORTS}
Pour inclure des opérations ou des constantes définies dans des machines
externes, il faut les ajouter respectivement dans les clauses \texttt{IMPORTS} et \texttt{SEES} de
la machine courante. Cependant, il n'y a pas de processus automatique pour
ajouter les machines nécessaires dans ces clauses. Il faut donc les ajouter
manuellement une fois la traduction est réalisée.


\subsection{Schéma général}

Le nom de la machine reprend le nom de la
définition Scade, cependant le nom de l'opération doit être différent du nom de
la machine, donc la première lettre sera une majuscule pour marquer la
différence de nom. 
Le shéma de traduction d'un composant Scade foo en une implémentation B est
le suivant:


\setlength{\columnseprule}{0.05cm}
\begin{multicols}{2}
\begin{alltt}
\textbf{node} foo 
  (in\(\sb{1}\): in\(\sb{1}\)\_type, ..., in\(\sb{p}\): in\(\sb{p}\)\_type) 
  \textbf{returns}
  (out\(\sb{1}\): out\(\sb{1}\)\_type, ..., out\(\sb{q}\): out\(\sb{q}\)\_type);
\textbf{var}
  v1 : v1\_type;
  ...
  vn : vn\_type;
  r1 : r1\_type;
  ...
  rn : rn\_type;
\textbf{let}
  assume in\(\sb{1}\) : pred\_in\(\sb{1}\);
  ...
  assume in\(\sb{p}\) : pred\_in\(\sb{p}\);

  \(liste d'equations\)

  guarantee out\(\sb{1}\) : pred\_out\(\sb{1}\);
  ...
  guarantee out\(\sb{q}\) : pred\_out\(\sb{q}\);
\textbf{tel;}
\end{alltt}

\columnbreak

\begin{alltt}
\textbf{IMPLEMENTATION} Foo_i
\textbf{REFINES} Foo

\textbf{IMPORTS} M\(\sb{imp}\)
\textbf{SEES} M\(\sb{see}\)

\textbf{CONCRETE\_VARIABLES} r1, ..., rn
\textbf{INVARIANT}
  r1 : r1\_type &
  ... &
  rn : rn\_type
\textbf{INITIALISATION}
  r1 := ;
  ... ;
  rn := ;

\textbf{OPERATION}

out\(\sb{1}\), ..., out\(\sb{q}\) \(\leftarrow\) foo(in\(\sb{1}\), ..., in\(\sb{p}\)) =
  
\textbf{VAR} v1, ..., vn \textbf{IN}
  
  \(sequence de substitutions\)

\textbf{END}
\end{alltt}
\end{multicols}

Les clauses invariant, initialisation et la séquence de substitutions
sont obtenues en appliquant la traduction des équations
sur la liste d'équations du composant Scade.

\section{Le traducteur}

Le traducteur a été écrit en OCaml, qui est un langage très efficace
pour développer des compilateurs, et donc des traducteurs.\\
Le parseur/lexeur a été écrit à partir de la grammaire de Scade,
définie dans le manuel Textual Scade.

Les programmes parsés sont alors représentés sous forme d'arbre de
syntaxe abstraite, donné en annexe A. Cette représentation permet une
manipulation sur les différents éléments du programme, telle que la
liste d'équation sur laquelle est effectuée l'algorithme du tri
topologique. \\
On identifie également les différentes équations que l'on
répertorie en opération de base, registres, appel de noeud, et
alternative.

Cet arbre est ensuite transformé en un arbre donné en annexe B,
qui peut être imprimé dans deux fichiers de sortie, correspondant à
la machine abstraite et à l'implantation correspondant au composant
donné en entrée. L'impression respecte la grammaire donnée dans le
Manuel de référence de B, et le couple de fichier peut être importé
dans un projet de l'Atelier B afin de vérifier le typage et la syntaxe
de chaque machine, et de passer les étapes d'obligation de preuve de
façon automatique.
