% -*- coding: utf-8; ispell-dictionary: "french"; -*-

%------------------------
% Chapter 2 - Machines B
%------------------------

Concernant le langage B, langage de sortie du traducteur, nous
n'aurons besoin d'utiliser que les éléments nécessaires pour exprimer
les éléments de Scade en B, et pour certifier formellement le
composant ainsi traduit.\\
La méthode B s'appuie sur un raisonnement mathématique rigoureux, basé
sur des étapes de raffinements. Nous n'aurons besoin que d'une étape de
raffinement pour notre traducteur. Il faudra ainsi produire deux
machines en sortie du traducteur:
\begin{itemize}
\item un contrat : elle correspond à la machine abstraite
  qui reprend les éléments de spécification du composant traduit.
\item une implantation : elle raffine la machine abstraite et
  contient les substitutions correspondant aux équations du composant.
\end{itemize}
La méthode B est utilisée avec l'environnement de développement
AtelierB, développé par Clearsy. Nous utiliserons cet environnement
pour vérifier que le code traduit est correctement traduit en B à
l'aide d'un analyseur syntaxique intégré ainsi qu'un vérificateur de types. On
utilise ensuite l'environnement pour générer les obligations de
preuves liées au couple de machines.



% SECTION 1 : Machines

\section{Machine B}

\subsection{Structure d'une machine}

Une machine B est divisée en \emph{clauses}, que l'on peut assimiler à
des services permettant l'initialisation puis l'évolution des données
manipulées. Une clause ne peut-être utilisée plus d'une fois dans une
machine, mais l'ordre n'est pas imposé. Il en existe une vingtaine,
mais nous n'en utiliserons que sept, que nous détaillerons dans la
partie suivante.\\ 
Ces données sont exprimées dans le même type qui est utilisé avec
Scade, c'est à dire soit des entiers, soit des réels, soit des
booléens, soit des tableaux de ces types.\\ 
La machine abstraite reprenant la spécification du composant contient
des prédicats portant sur ces données, et la transformation
de ces prédicats se fait grâce à un mécanisme de \emph{substitutions généralisées}.
Une machine est précédée d'un en-tête qui diffère selon la machine
abstraite et l'implantation:
\begin{itemize}
\item pour la machine abstraite, l'en-tête sera composé du mot \texttt{MACHINE} suivi
  du nom du composant.
\item pour l'implantation, ce sera \texttt{IMPLEMENTATION} suivi du nom du
  composant auquel on ajoute le suffixe "\_i".
\end{itemize}

\subsection{Clauses}
Les différentes clauses requises pour assurer la traduction sont
décrites dans cette partie. La machine abstraite ne requière pas les
clauses \texttt{IMPORTS}, \texttt{CONCRETE\_VARIABLES}, \texttt{INVARIANT} et \texttt{INITIALISATION} car
elle ne manipule que la spécification. En revanche, l'implémentation ne
manipule que des données et substitutions ayant un équivalent
informatique, similaire à un langage impératif, et on aura besoin de
ces clauses pour exprimer l'opération définie dans le composant Scade.

\paragraph{Refines}
La clause refines est présente dans la machine implémentation afin
d'indiquer la machine qui est raffinée. Nous ne faisons qu'une étape
de raffinement, donc la machine raffinée sera toujours la machine
abstraite. 

\paragraph{Imports}
Ici, nous indiquons quelles machines B seront nécessaires pour
manipuler les données. Pour la programmation par composant, nous avons
besoin de faire appel à d'autres composants, et cette clause permet
d'importer une instance de ces composants. Lors d'un appel d'opération d'une machine
importée, l'opération est instanciée.

\paragraph{Sees}
Nous avons besoin de faire aussi appel à des machines contenant
des définitions de constantes. Nous mettrons la liste des machines nécessaires
dans cette clause. Ce sont des machines vues, car il n'y a aucune instanciation
d'opération, on a seulement besoin de voir les constantes et leurs valeurs.

\paragraph{Concrete\_Variables}
Cette clause indique quelles sont les variables d'état de la
machine. C'est dans cette clause que nous déclarons les registres
définis dans le composant Scade. Les autres variables locales sont définies dans
une substitution \emph{Variable Locale}.

\paragraph{Invariant}
Nous pouvons alors établir des invariants sur les registres déclarés dans la
clause précédente dans cette clause. Les invariants indiquent le type et la restriction sur l'
intervalle sur lequel les registres seront manipulés. Ils seront écrits
sous forme de prédicats.

\paragraph{Initialisation}
L'initialisation permet d'indiquer la valeur donnée aux registres lors
de l'initialisation du composant, ce sont des substitutions. L'initialisation doit être en accord
avec l'invariant.

\paragraph{Opérations}
La clause principale d'une machine B est la clause Operations. On y
définit la spécification du composant dans la machine abstraite, et
cette spécification est concrétisée dans l'implantation où on écrira
les expressions du composant sous forme de substitutions et de prédicats. Bien
qu'on puisse définir autant d'opération qu'on le souhaite dans cette clause,
nous ne définirons qu'une seule opération, celle correspondant au composant Scade.


\subsection{Prédicats}

Un prédicat est une formule mathématique qui peut être prouvée ou
réfutée. Elle peut être présente pour exprimer des propriétés sur une
donnée, comme dans la clause \texttt{INVARIANT}, ou dans la substitution
\emph{Precondition}. Elle peut-être aussi utilisée pour exprimer une
condition, comme dans la substitution \emph{Condition}.

\paragraph{}
Les prédicats de base sont exprimables à l'aide des opérateurs de
comparaison habituels: \texttt{<, >, $\leq$}, et \texttt{$\geq$}. Les
expressions qui composent ces prédicats de base doivent
être de type entier ou réel.

\paragraph{}
Pour exprimer un prédicat plus complexe à partir de prédicats basique,
on utilise des connecteurs propositionnels : conjonction \texttt{$\vee$},
disjonction \texttt{$\wedge$}, négation \texttt{$\neg$}, implication
\texttt{$\Rightarrow$} et équivalence \texttt{$\Leftrightarrow$}.\\
Par exemple, soit $P$ et $Q$ des prédicats: $P\wedge\neg(Q)$ est
également un prédicat.

\paragraph{}
On utilisera aussi le quantificateur $\forall$, et on aura besoin de
l'opérateur d'appartenance à un ensemble $\in$.\\  
Ces opérateurs seront utiles lorsqu'on
définira des tableaux, pour établir une condition pour tous les
éléments du tableau.
Par exemple, soit $tab$ un tableau : $\forall iii . (iii \in (1..5)
\Rightarrow tab(iii) < 5)$\\
Cet exemple indique que tout élément du tableau ayant un indice compris
entre 1 et 5 doit être strictement inférieur à 5. 


% SECTION 2 : Expressions

\section{Expressions}

\paragraph{Expressions de base}
Les expressions permettent de désigner les données utilisées. Les
expressions de base désignent une variable ou une valeur primitive.
On retrouve toutes les expressions arithmétiques classiques, addition,
soustraction, multiplication, division et modulo. \\
On peut également transformer un prédicat en expression grâce à
l'opérateur $bool$, qui retournera une expression de
type BOOL. Par exemple, le prédicat $A < B$ peut être considéré comme
une expression ainsi : $bool(A < B)$. Cet opérateur sera surtout utile dans la
substitution \emph{Devient Egal} qui ne porte que sur des expressions.

\paragraph{Des fonctions}

Nous utiliserons également les fonctions, pour appeler des opérations
définies dans d'autres MACHINES, mais aussi pour modéliser les
tableaux en B. Il n'y a pas de type primitif tableau en B, il faut les
modéliser à l'aide de fonctions. 

\paragraph{Les tableaux en B}
Un tableau est donc une fonction dont l'ensemble de départ est le produit
cartésien de n ensembles (où n correspond au nombre de dimensions du
tableau), et dont l'ensemble d'arrivée est un ensemble concret.\\
Par exemple, soit $tab$ un tableau, \\
$tab \in (0..4)*(0..5) \rightarrow INT$ \\
est une matrice de 5 lignes et 6 colonnes contenant des entiers.\\

Les tableaux sont donc habituellement modélisé par des fonctions en B,
mais on aurait également pu utiliser le type \emph{séquence}. Ce
dernier correspond au type liste que l'on retrouve dans des langages
comme OCaml ou Scheme. Cependant, reproduire les opérations des
tableaux avec les séquence n'est pas aussi intuitive qu'avec les
fonctions.\\

Par exemple, la sélection d'un élément présent à l'indice i d'une
séquence T se fait à l'aide de deux opérateurs:
\begin{itemize}
\item $T\downarrow i$ : retourne la séquence T dont les i premiers
éléments on été supprimés.
\item $first(T)$ : retourne le premier élément de la séquence T
\end{itemize}
La sélection s'écrit alors: $first(T\downarrow i)$. Tandis qu'avec les
fonctions, la sélection s'écrit T(i) pour une fonction T modélisant un
tableau dans lequel on veux obtenir l'élément présent à l'indice i.

\paragraph{Ensembles en compréhension}
La définition d'ensemble en compréhension fait également partie des expressions de
B. On l'utilise notamment dans l'écriture des postconditions. A partir
de la condition sur la sortie, on obtient un ensemble qui respecte
cette propriété. A partir d'un ensemble $E$, et d'une
condition $C$ portant sur les éléments de l'ensemble, la définition
d'ensemble en compréhension s'écrit $\{ iii \in E | C \}$.


% SECTION 3 : Substitutions

\section{Substitutions}
Les substitutions permettent de transformer les prédicats, il en existe 18 mais
nous ne nous intéresseront qu'à la moitié d'entre elles. Soit une substitution S et un
prédicat P, \emph{[S]P} se lit "la substitution S établit le prédicat P".
Les substitutions ne sont présentes que dans les clauses Initialisation et
Operations. Dans la partie suivante, on détaillera comment passer des équations
de Scade à ces substitutions.


\paragraph{Substitution Devient égal}
Cette substitution réalise l'affectation, elle remplace une variable
par une expression. Notation : Soit e une expression, x une
variable et P un prédicat,

[ x:=e ] P \\
Le prédicat obtenu a alors toute les occurrences libre de x dans P par e.

\paragraph{Substitution Appel operation}
Notation : Soit R un identificateur correspondant à la sortie
de l'opération op appliquée aux expressions E, 

[R $\leftarrow$ op(E)]P\\
La  substitution appel d’opération permet d’appliquer la substitution
d’une opération (non locale ou locale), en remplaçant les paramètres
formels par des paramètres effectifs. 

\paragraph{Substitution Condition}
C'est cette substitution que l'on utilise pour exprimer le choix entre deux
substitutions. Notation : Soit P et R des prédicats, et S et T des
substitutions,

[IF P THEN S ELSE T]R \\
Si le prédicat P est évalué à vrai, alors c'est la substitution S que l'on
applique au prédicat R. Si P est faux, alors c'est la substitution T qui
s'applique à R.

\paragraph{Substitution Variable Locale}
Cette substitution n'est pas utilisée dans la machine abstraite. Elle permet
d'introduire une liste de variables locales.
Notation : Soit S une séquence de substitutions et X une liste de variables,

[VAR X IN S END]\\
La liste de variable sera accessible dans les substitutions S contenues dans le
bloc IN ... END, correpondant à une substitution bloc.

\paragraph{Substitution Sequence}
Une séquence permet d'appliquer en séquence deux substitutions à un
prédicat. Les deux substitutions sont séparées par un \textbf{;} .

\paragraph{}
On retrouve ainsi les constructions d'un langage de programmation
impératif, avec des affectations, appels d'opération, l'alternative, la
définition de variables locales et la séquence d'instructions.\\
Les substitutions suivantes ne pas utilisables dans une implantation. Elles
permettent d'exprimer des notions abstraites, et n'ont pas de correspondance
dans les langages de programmations.

\paragraph{Substitution Parallèle}
A la différence de la substitution séquence, la substitution parallèle permet
d'effectuer deux substitutions de façon simultanée et indépendamment l'une de
l'autre. Les deux substitutions sont séparées par \textbf{||} .

\paragraph{Substitution Devient Element De}
Les conditions sur les entrées et sorties du programmes sont souvent
des restrictions sur des ensembles de valeurs. Cette substitution permet
d'attribuer à une variable, une valeur tirée dans un ensemble. C'est
une substitution inderterminée. 
Notation: Soit E un ensemble et X une variable, 

[X:$\in$ E] \\

\paragraph{Substitution Precondition}
Cette substitution fixe les
préconditions sous lesquelles une substitution sera valide. Notation : Soit P
un prédicat et S une substitution,

[PRE P THEN S END]\\
L'application de cette substitution correspond à la preuve de la
précondition P et à l'application de la substitution S. Si la
précondition P est fausse, le résultat de la substitution n'est alors
plus garantit.

% SECTION 4 : Raffinements

\section{Raffinements}

\subsection{Principes du raffinement}

Le raffinement d'une machine est une reformulation en une
expression plus concrète et enrichie. La relation de raffinement est transitive:
si le raffinement est correct, les valeurs calculées par l'implantation sont
conformes à celles attendues par la machine abstraite.

L'implantation correspond à un code exécutable après une compilation vers du
code C ou Ada. Donc vers un programme semblable à celui écrit avec
Scade, qui est également compilé vers du C en fin de chaîne. Cependant
nous ne nous intéresserons pas au programme produit par l'atelierB,
car le compilateur de Scade produisant le C (KCG 6) est qualifié pour produire
du code certifié pour la norme DO178b.

Ainsi, le raffinement permet de concrétiser un programme jusqu'à obtenir un code
exécutable, mais il permet surtout de générer un certain nombre de preuves à
démontrer pour prouver que la reformulation de la spécification est valide.
La génération des propriétés à démontrer est automatique dans l'Atelier B, grâce à la
transformation des prédicats par les substitutions. 

La machine abstraite reprendra uniquement les éléments du contrat du composant,
c'est à dire les conditions indiquées sur les entrées et sorties du noeud
Scade. Ce sont ces conditions qui devront être vérifiée par les différents
raffinements de la machine abstraite. Nous n'utiliserons qu'une étape de
raffinement: l'implantation. Il faut donc prouver que cette machine raffinée
conserve les propriétés invariantes de la machine abstraite.

Dans le cadre du projet, nous n'avons qu'une étape de raffinement, et la forme
générale d'une machine abstraite et de son raffinement est le suivant: 
\newpage


\setlength{\columnseprule}{0.05cm}
\begin{multicols}{2}
\begin{alltt}
\textbf{MACHINE} M

\textbf{OPERATION}

outs \(\leftarrow\) op(ins) =
  \textbf{PRE}
    P
  \textbf{THEN}
    S
  \textbf{END}

\textbf{END}
\end{alltt}
\columnbreak
\begin{alltt}
\textbf{IMPLEMENTATION} M\_i
\textbf{REFINES} M

\textbf{IMPORTS} M\(\sb{imp}\)
\textbf{SEES} M\(\sb{see}\)

\textbf{CONCRETE\_VARIABLES} regs
\textbf{INVARIANT}
  Inv
\textbf{INITIALISATION}
  Ini

\textbf{OPERATIONS}
  
outs \(\leftarrow\) op(ins) =
  S'

\textbf{END}
\end{alltt}
\end{multicols}



\subsection{Obligations de preuves}

Pour chaque machine, de la spécification à l'implantation, il faut
passer trois étapes de vérification: au niveau syntaxique, le typage, et les obligations de preuves.  
Les obligations de preuves ont été définies dans le B-Book \cite{JRA}. 

\paragraph{Initialisation de l'implantation} Pour l'initialisation, la preuve
dépend des machines présentes dans les clauses IMPORTS et
SEES. L'obligation de preuve générée est la suivante:\\

\bcode{Inv$_{imp}$ $\wedge$ Inv$_{see}$ $\Rightarrow$ [Ini$_{imp}$; Ini] Inv} \\

Avec Inv$_{imp}$ et  Inv$_{see}$ les invariants des machines importées et vues,
et Ini$_{imp}$ les initialisations des machines importées. \\


\paragraph{Opération de l'implantation}
L'opération de l'implantation dépend également des machines importées et vues, mais
aussi et surtout de la machine qu'elle raffine. L'obligation générée est la
suivante:\\

\bcode{Inv$_{imp}$ $\wedge$ Inv$_{see}$ $\wedge$ Inv $\wedge$ P $\Rightarrow$
[[u:=u'] S']$ \neg
$[S]$ \neg $(Inv $\wedge$ u = u')}\\

Avec u correspondant aux sorties de la machine abstraite et u' les sorties de l'implantation.

\paragraph{}
Prenons un exemple. Soit la machine Integr, qui utilise la machine Bound,
générée à partir du noeud bound. Le couple de machines est le suivant:
\newpage
\setlength{\columnseprule}{0.05cm}
\begin{multicols}{2}
\begin{alltt}
\textbf{MACHINE} Integr

\textbf{OPERATION}

yy \(\leftarrow\) integr(xx) =
  \textbf{PRE}
    xx \(\in\) INT & -256 <= xx & xx <= 255
  \textbf{THEN}
    yy \(\in\): \{ yy | yy \(\in\) INT & 
          -1024 <= yy & yy <= 1023 \}
  \textbf{END}

\end{alltt}

\columnbreak

\begin{alltt}
\textbf{IMPLEMENTATION} Integr\_i
\textbf{REFINES} Integr

\textbf{IMPORTS} Bound

\textbf{CONCRETE\_VARIABLES} reg1
\textbf{INVARIANT}
  reg1 \(\in \) INT & -1024 <= reg1 & reg1 <= 1023
\textbf{INITIALISATION}
  reg1 := 0

\textbf{OPERATIONS}
  
yy \(\leftarrow\) integr(xx) =
\textbf{VAR} zz \textbf{IN}
   zz := xx + reg1; 
   yy \(\leftarrow\) bound(-1024, zz, 1023);
   reg1 := yy
\textbf{END}
\end{alltt}
\end{multicols}


La machine \texttt{Bound} n'a pas d'invariant ni d'initialisation, on ne s'intéresse donc qu'à l'invariant,
l'initialisation et les substitutions de la machine \texttt{Integr}. \\
Pour l'initialisation, on obtient l'obligation suivante:\\

\bcode{ $\Rightarrow$ [reg1:=0] reg1 $\in $ INT $\&$ -1024 <= reg1 $\&$ reg1 <=
1023} \\

\noindent
En appliquant la substitution à l'invariant on obtient:\\

\bcode{ $\Rightarrow$ 0 $\in $ INT $\&$ -1024 <= 0 $\&$ 0 <= 1023} \\

\noindent
ce qui est correct.\\
Concernant l'opération, la preuve est bien plus fastidieuse. Elle est disponible en annexe.
