% -*- coding: utf-8; ispell-dictionary: "french"; -*-

%------------------------
% Chapter 2 - Machines B
%------------------------

Concernant le langage B, langage de sortie du traducteur, nous
n'aurons besoin d'utiliser que les éléments nécessaires pour exprimer
les éléments de Scade en B, et pour certifier formellement le
composant ainsi traduit.\\
La méthode B s'appuie sur un raisonnement mathématique rigoureux, basé
sur des étapes de raffinements. Nous n'aurons besoin que d'une étape de
raffinement pour notre traducteur. Il faudra ainsi produire deux
machines en sortie du traducteur:
\begin{itemize}
\item une signature : elle correspond à la machine abstraite
  qui reprend les éléments de spécification du composant traduit.
\item une implantation : elle raffine la machine abstraite et
  contient les substitutions correspondant à l'opération définie dans
  le composant.
\end{itemize}
La méthode B est utilisée avec l'environnement de développement
AtelierB, développé par Clearsy. Nous utiliserons cet environnement
pour vérifier que le code traduit est correctement traduit en B à
l'aide d'un analyseur syntaxique intégré ainsi qu'un type checkeur. On
utilise ensuite l'environnement pour générer les obligations de
preuves liées au couple de machines.



% SECTION 1 : Machines

\section{Machine B}

\subsection{Structure d'une machine}

Une machine B est divisée en \emph{clauses}, que l'on peut assimiler à
des services permettant l'initialisation puis l'évolution des données
manipulées. Une clause ne peut-être utilisée plus d'une fois dans une
machine, mais l'ordre n'est pas imposé. Il en existe une vingtaine,
mais nous n'en utiliserons que sept, que nous détaillerons dans la
partie suivante.\\ 
Ces données sont exprimées dans le même type qui est utilisé avec
Scade, c'est à dire soit des entiers, soit des réels, soit des
booléens, soit des tableaux de ces types, qui sont des types primitifs
du langage B. \\ 
La machine abstraite reprenant la spécification du composant contient
des prédicats portant sur ces données, et la transformation
de ces prédicats se fait grâce à un mécanisme de substitutions. Les
différentes substitutions requises pour ce projet seront détaillées
dans la partie correspondante. \\
Une machine est précédée d'un en-tête qui diffère selon la machine
abstraite et l'implantation:
\begin{itemize}
\item pour la signature, l'en-tête sera composé du mot MACHINE suivi
  du nom du composant.
\item pour l'implantation, ce sera IMPLEMENTATION suivi du nom du
  composant auquel on ajoute le suffixe "\_i".
\end{itemize}
Voir annexe A pour un exemple de couple de machines abstraite/implantation.



\subsection{Clause}
Les différentes clauses requises pour assurer la traduction sont
décrites dans cette partie. La machine abstraite ne requière pas les
clauses IMPORTS, CONCRETE\_VARIABLES, INVARIANT et INITIALISATION car
elle ne manipule que la spécification. En revanche, l'implémentation ne
manipule que des données et substitutions ayant un équivalent
informatique, similaire à un langage impératif, et on aura besoin de
ces clauses pour exprimer l'opération définie dans le composant Scade.

\paragraph{Refines}
La clause refines est présente dans la machine implémentation afin
d'indiquer la machine qui est raffinée. Nous ne faisons qu'une étape
de raffinement, donc la machine raffinée sera toujours la machine
abstraite. 

\paragraph{Imports}
Ici, nous indiquons quelles machines B seront nécessaires pour
manipuler les données. Pour la programmation par composant, nous avons
besoin de faire appel à d'autres composants, et cette clause permet
d'importer une instance de ces composants.

\paragraph{Sees}
Nous avons besoin de faire aussi appel à des machines contenant
des définitions de constantes. Nous mettrons la liste des machines nécessaires
dans cette clause.

\paragraph{Concrete\_Variables}
Cette clause indique quelles sont les variables d'état de la
machine. C'est dans cette clause que nous déclarons les registres
définis dans le composant Scade. Les autres variables locales sont définies dans
une substituion VAR.

\paragraph{Invariant}
Nous pouvons alors établir des invariants sur les registres utilisés
dans cette clause. Les invariants seront des restrictions sur les
intervalles sur lesquels les registres seront manipulés, et ils seront écrits
sous forme de prédicats.

\paragraph{Initialisation}
L'initialisation permet d'indiquer la valeur donnée aux registres lors
de l'initialisation du composant. L'initialisation doit être en accord
avec l'invariant.

\paragraph{Opérations}
La clause principale d'une machine B est la clause Operations. On y
défini la spécification du composant dans la machine abstraite, et
cette spécification est concrétisée dans l'implantation où on écrira
les expressions du composant sous forme de substitutions et de prédicats. Bien
qu'on puisse définir autant d'opération qu'on le souhaite dans cette clause,
nous ne définirons qu'une seule opération, celle correspondant au composant Scade.


\subsection{Prédicats}

Un prédicat est une formule mathématique qui peut être prouvée ou
réfutée. Elle peut être présente pour exprimer des propriétés sur une
donnée, comme dans la clause \emph{Invariant}, ou dans la substitution
Precondition. Elle peut-être aussi utilisée pour exprimer une
condition, comme dans la substitution Condition.

\paragraph{}
Les prédicats de base sont exprimables à l'aide des opérateurs de
comparaison habituels: $<,~>,~\leq,$et $\geq$. Les expressions doivent
être de type entier ou réel.

\paragraph{}
Pour exprimer un prédicat plus complexe à partir de prédicats basique,
on utilise des opérateurs de proposition : conjonction $\vee$,
disjonction $\wedge$, négation $\neg$, parenthèses $()$, implication
$\Rightarrow$ et équivalence $\Leftrightarrow$.\\
Par exemple, soit $P$ et $Q$ des prédicats: $P\wedge\neg(Q)$

\paragraph{}
On utilisera aussi le quantificateur $\forall$, notamment lorsqu'on
définira des tableaux, pour établir une condition pour tous les
éléments du tableau. Et on aura besoin de l'opérateur d'appartenance à
un ensemble $\in$.\\
Par exemple, soit $tab$ un tableau : $\forall iii . (iii \in (1..5)
\Rightarrow tab(iii) < 5)$\\
Cet exemple indique que tout élément du tableau ayant un indice compris
entre 1 et 5 doit être strictement inférieur à 5. Nous reviendrons en
détail sur le fonctionnement des tableaux en B dans la section sur les
expressions.

%% NOTE: ON PEUT SE PASSER DU APPARTIENT AVEC \\
%% !iii . (iii : INT $\wedge$ iii > 0 $\wedge$ 6 > iii => tab(iii) < 5) \\
%% A REGARDER DANS IMPLEM


% SECTION 2 : Expressions

\section{Expressions}

\paragraph{}
Les expressions permettent de désigner les données utilisées. Les
expressions de base désignent une variable ou une valeur primitive.
On retrouve toutes les expressions arithmétiques classiques, addition,
soustraction, multiplication, division et modulo.

\paragraph{Des fonctions}

Nous utiliserons également les fonctions, pour appeler des opérations
définies dans d'autres composants, mais aussi pour modéliser les
tableaux en B. Il n'y a pas de type primitif tableau en B, il faut les
modéliser à l'aide de fonctions.

\paragraph{Les tableaux en B}
Un tableau est une fonction dont l'ensemble de départ est le produit
cartésien de n ensembles (où n correspond au nombre de dimensions du
tableau), et dont l'ensemble d'arrivée est un ensemble concret.\\
Par exemple, soit $tab$ un tableau, \\
$tab \in (0..4)*(0..5) \rightarrow INT$ \\
est une matrice de 5 lignes et 6 colonnes contenant des entiers.


% SECTION 3 : Substitutions

\section{Substitutions}
Les substitutions permettent de transformer les prédicats, il en existe 18 mais
nous ne nous intéresseront qu'à la moitié d'entre elles. Soit une substitution S et un
prédicat P, \emph{[S]P} se lit "la substitution S établit le prédicat P".
Les substitutions ne sont présentes que dans les clauses Initialisation et
Operations. Dans la partie suivante, on détaillera comment passer des équations
de Scade à ces substitutions.

\paragraph{Substitution Bloc}
La substitution bloc est la substitution de base, elle permet de grouper des
substitutions. Elles contient une substitution ou une séquence de substitution.
Elle se note : Soit S une substitution, \\
$BEGIN~ S~ END$ 

\paragraph{Substitution Sequence}
Une séquence permet d'appliquer en séquence deux substitutions à un
prédicat. Les deux substitutions sont séparées par un $;$.

\paragraph{Substitution Parallèle}
A la différence de la substitution séquence, la substitution parallèle permet
d'effectuer deux substitutions de façon simultanée et indépendamment l'une de
l'autre. Les deux substitutions sont séparées par $||$. Cette substitution n'est
disponible que pour la machine abstraite.

\paragraph{Substitution Devient égal}
Cette substitution réalise l'affectation, elle remplace une variable
par une expression. Elle se note : Soit e une expression, x une
variable et P un prédicat, \\ 
$[x:=e]P$  \\
Le prédicat obtenu a alors toute les occurrences libre de x dans P par e.

\paragraph{Substitution Devient Element De}
Les conditions sur les entrées et sorties du programmes sont souvent
des restrictions sur des ensembles de valeurs. Cette substitution permet
d'attribuer à une variable, une valeur tirée dans un ensemble. Elle se note:
Soit E un ensemble et X une variable, \\
$X:\in E$\\
Cette substitution n'est pas une substitution d'implantation.

\paragraph{Substitution Condition}
C'est cette substitution que l'on utilise pour exprimer le choix entre deux
substitutions. Elle se note : Soit P et R des prédicats, et S et T des substitutions,\\
$[IF~ P~ THEN~ S~ ELSE~ T]R$ \\
Si le prédicat P est évalué à vrai, alors c'est la substitution S que l'on
applique au prédicat R. Si P est faux, alors c'est la substitution T qui
s'applique à R.

\paragraph{Substitution Variable Locale}
Cette substitution n'est pas utilisée dans la machine abstraite. Elle permet
d'introduire une liste de variables locales.
Elle se note : Soit S une séquence de substitutions et X une liste de variables,\\
$VAR~ X~ IN~ S~ END$\\
La liste de variable sera accessible dans les substitutions S contenues dans le
bloc IN ... END, correpondant à une substitution bloc.

\paragraph{Substitution Precondition}
Cette substitution n'est utilisée que dans la machine abstraite. Elle fixe les
préconditions sous lesquelles une substitution. Elle se note : Soit P
et R des prédicats et S une substitution,\\ 
$[PRE~ P~ THEN~ S~ END]R$\\
L'application de cette substitution correspond à la preuve de la
précondition P et à l'application de la substitution S. Si la
précondition P est fausse, le résultat de la substitution n'est alors
plus garantit.

\paragraph{Substitution Appel operation}
cette substitution se note : Soit R un identificateur correspondant à la sortie
de l'opération op appliquée aux expressions E, et un prédicat P,\\
$[R\leftarrow op(E)]P$\\
La  substitution appel d’opération permet d’appliquer la substitution
d’une opération (non locale ou locale), en remplaçant les paramètres
formels par des paramètres effectifs. 

\paragraph{}
On retrouve ainsi les constructions d'un langage de programmation
impératif, avec des affectations, appels d'opération, alternative, et la
définition de variables locales. De plus, les substitutions sont
réordonnées via un tri topologique par rapport aux équations du composant
Scade, dont l'ordre n'avait pas d'importance. Cette distinction entre
les deux langages, synchrone contre impératif, sera développée dans la
section concernant la preuve de correction du traducteur.


% SECTION 4 : Raffinements

\section{Raffinements}

\subsection{Principes du raffinement}

Le raffinement d'une machine est une reformulation en une
expression plus concrète et enrichie. La relation de raffinement est transitive:
les valeurs calculées par l'implantation sont conformes à celles attendues par
la machine abstraite. 

L'implantation correspond à un code exécutable après une compilation vers du
code C ou Ada. Donc vers un programme équivalent à celui écrit avec
Scade, qui est également compilé vers du C en fin de chaîne. Cependant
nous ne nous intéresserons pas au programme produit par l'atelierB,
car le compilateur de Scade produisant le C (KCG 6) est qualifié pour produire
du code certifié pour la norme DO178b.

Ainsi, le raffinement permet de concrétiser un programme jusqu'à obtenir un code
exécutable, mais il permet surtout de générer un certain nombre de preuves à
démontrer pour prouver que la reformulation de la spécification est valide.
L'activité de preuve d'une machine B consiste à la
réalisation d'un certain nombre de démonstrations, afin de prouver
l'établissement et la conservation des propriétés invariantes de la
spécification.
La génération des hypothèses à démontrer est automatique dans l'Atelier B, grâce à la
transformation des prédicats par les substitutions. 

La machine abstraite reprendra uniquement les éléments du contrat du composant,
c'est à dire les conditions indiquées sur les entrées et sorties du noeud
Scade. Ce sont ces conditions qui devront être vérifiée par les différents
raffinements de la machine abstraite. L'implémentation repdrendra elle 


[

-

L'atelier B produit automatiquement les obligations de preuves
nécessaires pour valider le raffinement. Ces obligations sont
construites ...

Cf intro obligation proof paper

]


\subsection{Obligations de preuves}
Cf Proof obligation paper

A chaque raffinement, on passe par une étape de type checking et
d'obligation de preuves. Démonstrations basée sur les principales
substitutions. Montrer qu'on utilise ce qu'il faut pour assurer que
les obligations de preuves sont possibles.

Principe :

Hypothèses (liste de prédicats)
=>
But (doit être prouvé sous ces hypothèses)

Pour cela on applique des substitutions aux prédicats. Développer pour les
différentes substitutions, exemples...

